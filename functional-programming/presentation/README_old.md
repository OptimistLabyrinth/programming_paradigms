# 함수형 프로그래밍

## 1. 장점

실용적이다
극도로 구체적이다
부수 효과(side effect) 를 잘 다둘 수 있다
분산 시스템에 적용하기 쉽다

## 2. 시작하기

### 기존의 개념 위에 손쉽게 적용 가능

Name, Value, If, Loop, Return
String, Numerics, Boolean
Array, Hash, List, Map
Namespace, Indentation
Class, Inheritance, Method

프로그래밍을 하면서 배운 기존의 개념을 모두 버려야 하는 것은 아니다
이분법적으로 예/아니오 나눠서 생각할 필요는 없음
기존의 코드, 아키텍쳐에 함수형 요소를 약간만 첨가하면 효율적으로 개선 가능

## 3. 구성 요소

### 3.1. 순수성 보장

함수의 개념??
어떤 함수 f 에 대해서 x 를 입력하면 결과는 항상 f(x) 가 된다

x1 --- f ---> f(x1)
x2 --- f ---> f(x2)
x3 --- f ---> f(x3)

프로그래밍에서의 함수도 이와 비슷하다
입력과 출력, 구현 몸체가 있다

x = ['a', 'b', 'c']
y = a(x)
x = ?

x = ['a', 'b', 'c']
y = c(a(x) + b(x)) + d(x) * e(x)
    - 4 * ((q(x) - f(x)) + (d(x) + g(x) - k(x) + 7))
    ...
    - z(n(x))
x = ?

진정으로 순수한 함수라면
입력과 출력 쌍에 대해서 Lookup Table 을 만들 수 있어야 한다.

추가적인 장점
[1] Cache
    >> memoization
[2] Parallel Processing
    >> map-reduce structure
[3] Lazy Operation
    >> yield syntax

### 3.2. 불변성 보장

앞에서 함수의 불변성을 보장하기로 약속했지만
그래도 파라미터와 리턴값 자체가 결코 변하지 않도록 만들면 훨씬 더 안정감 있을 듯 하다

Persistent Data Structure (Copy-On-Write, Copy-On-Modify)

대표적인 예시는 List
A -> B -> C -> D 와 같은 리스트에서
B 를 Q 로 변경한다면
바뀌는 B 또는 Q 전까지인 A 는 공유하고 변경점 이후로만 새로 만든다

이보다 훨씬 더 효율적인 자료구조는 B-tree 비슷한 트리 구조를 적용하는 것

읽기를 하는 영역과 쓰기를 하는 영역을 구분해야 한다

#### 3.3. 부수 효과

프로그래밍의 세계에서 본질적으로 부수 효과를 피할 수는 없다
부수 효과의 결과를 저장하는 곳이 어딘가 반드시 있어야 한다
이렇게 저장한 정보는 어떤 함수의 출력값이기도 하고 다른 함수의 입력값으로 사용되기도 한다

"변수" 라는 단어는 변할 수 있는 수 라는 의미라서 헷갈릴 수 있으니
immutable 의미를 살리기 위해서 아톰(Atom) 이라는 단어를 사용하자

어떤 아톰에 59 라는 값이 들어있다
어떤 함수의 구현내용은 f(x) = x + 1 이다

예를 들어 이 아톰에 대해서 f(x) 연산이 동시다발적으로 3번 호출되었다고 하면
최종적으로 이 아톰에는 어떤 값이 저장되어 있을까?

+1 연산이 세번 이루어졌으니 59 + 3 = 62 가 저장되어 있기를 바라곘지만
함수의 입력값으로 사용하기 위해서 아톰의 값을 읽는 순간
함수의 출력값틀 저장하기 위해서 아톰에 값을 쓰는 순간
이런 타이밍이 상호간섭하면서 62 가 아닌 값이 저장될 수도 있다

오류를 방지하기 위해서 아톰에는 agent/actor 라는 방식을 적용하게 된다
모든 아톰은 개별적으로 태스크큐(task queue)를 갖고 있고
함수 호출이 발생하면 입력값, 함수를 적절한 형태로 가공해서 태스크큐에 집어넣고
집어넣은 순서대로 태스크큐에서 하나씩 꺼내서 실행한다

### 3.4. 액션, 게산, 데이터

위에서 살펴본 함수형 프로그래밍의 구성요소를 바탕으로 생각해보면
부수 효과가 있는 행동과 부수 효과가 없는 행동을 구분한다면 또는 구분할 수 있다면
코드를 다루는 과정이 훨씬 편리해질 것 같다는 생각이 든다

[1] 액션(Action)

부수 효과(side effect)가 있느 함수
순수하기 않은 함수(impure function)

[2] 계산(Calculation)

순수 함수(pure function)
수학적 함수(mathematical function)

[3] 데이터(Data, Fact, Event)

객관적 정보
이벤트에 대한 사실

----

액션, 계산, 데이터는 어디에나 적용할 수 있다.

(예시 1) 장보기 과정
(예시 2) 쿠폰 보내기

(예시 3) 장보기 서비스 장바구니

함수형 프로그래밍 방식으로 리팩터링 하기
암시작 입력(implicit input)과 암시적 출력(implicit output) 없애기

함수 구현 시
>> 전역 변수 사용을 거부하기
>> 입력은 파라미터로 받기
>> 출력은 리턴값으로 넘기기
>> 게산(calculation) 영역을 별도의 함수로 분리하기

#### 3.4.1. 계층형 설계

이런식으로 하나씩 리팩터링 하다보면
전체 아키텍쳐는 계층형 설계를 이루게 된다

결과적으로는 트리 형태의 호출 관계가 만들어지고
위쪽 계층일수록 도메인 비즈니스 로직을 나타내고
아래쪽 계층일수록 언어가 제공하는 기능, 자료구조에 접근하는 함수 등을 나타내게 된다

함수 호출은 언제나 위쪽 계층에서 아래쪽 계층을 호출하도록 한다

위쪽 계층일수록 각각의 함수가 담당하는 내용이 많아지고
아래쪽 계층으로 갈수록 하나의 함수가 담당하는 구현 내용이 적어진다

기능 변경이라는 관점에서 보면
위쪽 계층일수록 쉽고
아래쪽 게층일수록 어렵다
이유: 아래쪽 계층에 속하는 함수는 자신을 호출하는 곳이 많기 때문에 한번 한번의 수정 과정에서 고려해야 하는 부분이 더 많아진다

테스트 작성이라는 관점에서 보면
위쪽 계층일수록 어렵고
아래쪽 계층일수록 쉽다
이유: 아래쪽 계층을 구현 내용이 적어지고 간단해지기 때문에 테스트를 만들때 고려해야 하는 요소가 적어진다

#### 3.4.2. 타임라인 조율

동시성 구현을 설계 및 파악하는데 도움을 준다

[1] 하나의 작업을 시작해서 완료하기까지의 중간단계를 잘게 여러개의 태스크로 쪼갠 뒤
[2] 반드시 함께 실행해야만 하는 작업끼리 묶고
[3] 동시에 실행해도 되는 묶음이 발견되는 경우 둘 이상의 타임라인에 수평으로 올려둔다
[4] 하나의 태스크(또는 태스크 묶음)를 실행한 뒤에 다른 태스크(또는 태스크 묶음)를 실행해야 하는 경우
    둘 사이의 관게를 명확하게 나타내기 위해서 중간에 점선으로 표시한다

### 3.5. 일급 함수

다른 함수를 파라미터로 받기
리턴값으로 함수 형태를 넘기기

### 3.6. 모나드와 펑터

더하기, 빼기, 곱하기 연산을 구현하는 함수들

함수를 호출할때마다 로그를 남겨야 한다면 어떻게 구현해야 할까??






