가 나 다 라 마 바 사 아 자 차 카 타 파 하 가 나 다 라 마 바 사 아 자 차 (velog 한 줄)
가 나 다 라 마 바 사 아 자 차 카 타 파 하 가 나 다 라 마 바 사 아 자 차 (linkedin 한 줄)
가 나 다 라 마 바 사 아 자 차 카 타 파 하 가 나 다 라 마 바 사 아 자 (facebook 한 줄)

주제는 함수형 프로그래밍 시작해보기
---------- ---------- ---------- ---------- ----------
<시리즈 목차>
(1) 함수형 프로그래밍의 의의
(2) 함수형 프로그래밍의 필수 구성요소 1 - 함수의 순수성
(3) 함수형 프로그래밍의 필수 구성요소 2 - 변수의 불변성
(4) 불변 자료구조 구현 방법 예시
(5) 신뢰할 수 없는 코드베이스에서 불변성 유지하기
(6) 함수형 원리로 리팩터링하는 예제 1 - 액션, 계산, 데이터
(7) 함수형 원리로 리팩터링하는 예제 2 - 고차함수, 일급객체
(8) 함수형 프로그래밍 원리를 적용한 아키텍처
(9) 함수의 순수성을 보장했을때의 장점
(10) 함수형 프로그래밍 배경 지식 1 - Normal World & Wrapper World
(11) 함수형 프로그래밍 배경 지식 2 - 타입, 함수 합성, 부분 함수, 펑터(Functor)
(12) 함수형 프로그래밍에서 부수효과(side effect)를 다루는 방법 1
(13) 함수형 프로그래밍에서 부수효과(side effect)를 다루는 방법 2 - 또다른 비유
(14) 부수효과 다루는 방법을 적용해서 리팩터링하는 예제
(15) 함수형 프로그래밍 잘 시작해보기(요약 정리)

---------- ---------- ---------- ---------- ----------
[1] 함수형 프로그래밍의 의의
URL ( 함수형-프로그래밍-시작해보기-1-함수형-프로그래밍의-의의 )

함수형 프로그래밍을 처음 접하는 경우라면
새로운 단어들로 인해서 지레 겁먹을 수도 있다.

"내가 기존에 알고 있던 지식을 다 내려놓고
새롭게 받아들일 준비를 해야할까??"
와 같이 부담감을 갖는다거나

"나는 지금까지 개발업무를 맡아서 잘 해냈으니까
함수형 프로그래밍을 배워봤자 시간만 들고 방해가 될 뿐이야.
그냥 기존에 하던 것에나 매진하자"
라는 방식으로 거부감을 갖고 오해를 할 수도 있다.

하지만 실제로는 전혀 그렇지 않다.
함수형 프로그래밍의 기본원칙들은 아주 실용적인 방식으로
모든 개발자에게 도움이 될거라고 생각한다.

[[사람들이 기존에 갖고 있는 프로그래밍에 대한 지식]]

프로그램을 구현한다고 하면
이름을 정해서 변수를 선언하고
변수에 값을 할당한 뒤 조건문, 반복문을 이용해서 로직을 전개하고
필요한 경우에 함수를 호출해서 해야할 일을 한다.
문자열, 숫자, 이진 타입 등을 지정해서 변수가 하는 일에 제약을 두고
네임스페이스를 이용해서 코드 조각들을 적절하게 모듈화하고
배열, 리스트, 맵 등의 적절한 자료구조를 골라서 사용한다.
클래스, 상속, 메서드 등을 사용해서 적절하게 추상화를 해서
코드를 정제된 구조로 관리할 수도 있다.
이런 수많은 요소를 조합하다보면
최종적으로는 내가 처음에 만들고자 했든 프로그램을 완성할 수 있게 된다.

그러면 이렇게 많은 프로그래밍에 대한 지식 더미에서
함수형 프로그래밍은 어떤 역할을 할 수 있을까??

[[프로그래밍에 대한 기존 지식, 완성된 프로그램 사이에 빈 공간]]

나는 함수형 프로그래밍이
기존에 프로그래머들이 알고 있는 지식을
리팩터링하는 역할을 한다고 생각한다.
위에 그림처럼 가득 쌓여있는 프로그래밍 지식 더미 위에
함수형 프로그래밍이라는 계층을 하나 추가하면
완성된 프로그래밍을 조금 더 나은 구조로 만들고
개발자가 변화하는 요구조건에 대응하기에 조금은 편한 구조로 개선한다.

그러면 여기에 보이는 빈 공간을
함수형 프로그래밍의 핵심요소로 채워나가보자.

<참조>
유튜브 영상, [Functional Programming in 40 Minutes • Russ Olsen • GOTO 2018](https://youtu.be/0if71HOyVjY?si=pbupT8bhNCO77KAL)

---------- ---------- ---------- ---------- ----------
[2] 함수형 프로그래밍의 필수 구성요소 1 - 함수의 순수성
URL ( 함수형-프로그래밍-시작해보기-2-함수의-순수성 )

함수형 프로그래밍을 지탱하는 두 개의 큰 축이 있다.

- (1) 함수의 순수성(참조 투명성)을 보장하는 것
- (2) 변수의 불변성을 보장하는 것

이 두 가지가 함수형 프로그래밍의 80% 이상을 구성한다.
아무리 화려한 수식과 현란한 함수형 테크닉을 사용하더라도
함수의 순수성, 변수의 불변성 둘 중에 하나라도 보장하지 못한다면
함수형 프로그래밍과는 한참 동떨어진 코드라고 봐야 한다.

(1) 함수의 순수성

함수의 순수성 이라는 말에서 제일 먼저 보이는 단어는 함수 라는 단어다.
함수란 무엇일까??

[[함수 설명 A —f—> B]]

함수는 두 집합 사이의 관계를 설명하는 대수적 개념으로
A 라는 모든 요소 각각을 B 에 속한 하나의 요소로
사상할 수 있는 상태를 의미한다.
프로그래밍 용어로 번역해보자면 어떤 함수 f 에
파라미터로 A 집합에 속한 요소 중 하나를 전달한다면
B 집합에 속한 요소 중 하나를 반환한다는 의미가 된다.

흔히 이렇게 수학적 함수에 가까운 함수를
함수형 프로그래밍에서는 '순수 함수(pure function)' 라고 부른다.

프로그래밍 관점에서 '순수 함수(pure function)' 란 무엇일까??
함수 내에서 발생하는 부수효과(side effect)가 없는 함수를 의미한다.
사이드 이펙트, 부수 효과는 다음과 같은걸 말한다.
- 변수에 새로운 값 할당
- 자료구조를 in-place 로 변경
- 오브젝트의 어떤 필드에 값 세팅
- 예외 던지기
- 오류 발생으로 인한 프로그램 중단
- 콘솔 입출력
- 파일 입출력
- 네트워크 통신
- 스크린에 그림 그리기, UI 렌더링
함수 내에 위에서 언급한 것들처럼
함수 스코프를 벗어나서 영향을 끼치는 게 있다면
그 함수는 비순수 함수(impure function)가 된다.
함수형 프로그래밍에서는 순수하지 않은 함수(impure function)를
바람직하지 않은 것으로 보고 비순수 함수를 최소화하려고 노력한다.

함수형 프로그래밍에서는 순수 함수를 왜 강조하는지 궁금할 것이다.
에를 들어서 아래와 같은 코드가 있다고 생각해보자.

[[간단한 함수를 호출하는 코드]]

처음에 x 라는 변수에 a,b,c 세 개의 요소를 담고 있는
배열 또는 리스트가 있다고 가정해보자.
이 x 를 아규먼트로 전달해서 함수 a 를 호출하고 결과값을 y 로 받았다.
이 상태에서 x 에는 어떤 값이 들어있을까?
함수 a 를 호출하기 전 상태인 a, b, c 세 개짜리 리스트일까?
아니면 내부 요소가 바뀌어서 d, e, f 리스트가 되었을까?
이를 알아내려면 a 함수의 내부 구현코드를 열어서
처음부터 끝까지 한 줄씩 확인해야 한다.
중간에 파라미터로 받은 변수 x 를 변경하는 코드가
있는지 없는지 파악한다.
그렇게 하고 나서야 확신을 갖고 마지막줄 x 에 무엇이 들어있는지
말할 수 있게 된다.

다른 예시를 보자.

[[복잡한 함수를 호출하는 코드]]

이번에는 함수 하나만 간단하게 호출하는게 아니고
y 변수의 값을 얻기 위해서 이렇게 복잡하게 함수를 호출한다고 가정해보자.
이때는 마지막줄 x 에 무엇이 들어있는지 어떻게 알 수 있을까?
함수를 하나씩 다 확인하면서 뭐가 들어있는지 알아내면 될까?
하지만 각각 함수가 엄청나게 복잡하고 미묘한 로직으로 가득해서
파악하는게 너무나 부담스럽다면?
이런 상황이 발생하는 것을 방지하기 위해서
함수형 프로그래밍은 하나의 약속을 제시한다.
함수를 언제나 '순수 함수(pure function)'로 구현하자고 말이다.
'순수 함수(pure function)' 는 부수효과가 없으므로
함수 내부에서 값을 변경하는 경우가 없다.
설령 함수 내부에서 선언한 변수들의 값을 마음껏 변경하면서 사용하더라도
함수 외부에서 선언한 변수들의 값은 변경하지 않기로 약속했으므로
복잡한 함수 호출을 완료한 뒤에도
마지막줄 x 에 처음에 할당한 값 a,b,c 리스트가
그대로 들어있다고 말할 수 있다.
이 약속을 꾸준히 지킨다면
작업을 할때마다 함수 내부구현을 일일이 들여다봐야하는
고통과 귀찮음 덜어낼 수 있다.

[[함수형 프로그래밍의 첫번째 약속, 첫번째 필수요소, 함수의 순수성 보장]]

함수를 구현할때 언제나 순수 함수가 되도록 하는 것
함수의 순수성을 보장하는 것이 바로 빈 칸에 들어갈 첫번째 요소이다.

<참조>
유튜브 영상, [No Nonsense Monad & Functor - The foundation of Functional Programming by César Tron-Lozai](https://youtu.be/e6tWJD5q8uw?si=i6wagObBBBht_wsD)
유튜브 영상, [Functional Programming in 40 Minutes • Russ Olsen • GOTO 2018](https://youtu.be/0if71HOyVjY?si=pbupT8bhNCO77KAL)

---------- ---------- ---------- ---------- ----------
[3] 함수형 프로그래밍의 필수 구성요소 2 - 변수의 불변성
URL ( 함수형-프로그래밍-시작해보기-3-변수의-불변성 )

모든 함수를 순수 함수(pure function)로 구현하는 것만으로는
모든 걱정을 해결하지는 못한다.
예시를 하나 살펴보자.

[[원래 리스트의 요소 중 하나를 바꾸기]]

프로그래밍을 하다보면
변수를 선언하고 변수에 값을 할당하고 변수에 담겨있는 값을 변경하고 하는
이런 과정들이 너무나 자연스러운 행동들이다.
이렇게 변수를 마음껏 추가, 변경, 삭제 가능하다는 사실은
함수형 프로그래밍의 세계에서는 아주 중대한 이슈가 된다.

[[복잡한 함수를 호출하는 코드 다시]]

앞에서 봤던 예시를 다시 떠올려보자.
복잡하게 함수를 호출해야 하는 로직이 있다고 생각해보자.
지난번에는 모든 함수를 순수 함수(pure function)로 구현하기 때문에
세번째줄 x 에는 처음의 값 a,b,c 를 담은 리스트가 된다고 말했다.
하지만 엄밀하게 말하면 꼭 그렇지는 않다.
함수에서만 부수효과를 없애기로 약속한거지
변수 자체는 언제든지 바꿀 수 있다.
그래서 이 복잡한 로직 가운데 어딘가에
x[1] = 'Q' 처럼
변수 x 에 새로운 값을 할당하는 로직이 숨어있을 수도 있다.
이런 부수효과를 일으키는 동작이 하나라도 있다면
두 개, 세 개 있더라도 전혀 이상하지 않으므로
구현내용을 끊임없이 의심하고 확인해야 하는 어려움이 생긴다.

[[Immutable]]

이런 복잡한 상황을 방지하기 위해서
함수형 프로그래밍은 또 하나의 약속을 제시한다.
변수를 언제나 '불변하게(immutable)' 관리하자고 말이다.
'불변하다(immutable)' 라는 말은
어떤 변수에 한번 값을 할당하고 나면
어떤 방법으로도 해당 변수의 값을 바꿀 수 없게 만들자는 것이다.
해당 변수가 참조하고 있는 객체를 변경하는 것이 불가능할 뿐만 아니라
내부의 필드, 프로퍼티, 메타데이터 등
이 변수에 있는 아무 요소도 추가, 수정, 삭제할 수 없게 만들어야 한다.

하지만 현실적으로는
코드를 작성하다보면 값을 변경하는 경우가 반드시 있다.

[[Copy-On-Write]]

이를 위해서 함수형 프로그래머들은
흔히 copy-on-write 라는 테크닉을 적용한다.
예를 들어서 리스트 L 을 입력받아서 i 번째 인덱스 요소를 x 로 바꾸는
함수 f(L, i, x) 가 있다고 해보자.
이 함수를 적절한 아규멘트로 호출하는 상황을 상상해보자.
a,b,c 리스트가 있을때 인덱스 1에 있는 요소를 Q 로 바꿔서
a,Q,c 리스트로 바꾸는 로직을 만든다면
다음과 같은 순서로 동작하도록 구현해야 한다.

함수에 원본 리스트 a,b,c 를 전달한다.
-> 원본 리스트를 deep-copy 해서 새로운 리스트 a,b,c 를 만든다
-> 새로운 리스트의 인덱스 1에 있는 요소를 Q 로 바꿔서
    a,Q,c 로 만든다
-> 새로운 리스트 a,Q,c 를 반환한다.

[[Persistent Data Structure]]

변수의 '불변성(immutability)' 보장하는 로직을 매번 새롭게 구현해서
변수를 변경할때마다 스스로 신경써서 원본 데이터를 복제하는 것은
너무 귀찮기도 하고 개인이 실수할 여지를 많이 남긴다.
이런 대부분의 평범한 사용자들을 위해서 코어 라이브러리 개발자들은
불변 자료구조(persisten data structure)를
미리 구현해서 제공한다.

불변 자료구조는 데이터를 저장하고 가공하는 인터페이스는
기존의 자료구조와 비슷하지만
추가, 삭제, 가공할때 '불변성(immutable)' 이라는 특성을
최대한 지키도록 위에서 언급한 copy-on-write 방식으로 동작한다.

[[함수형 프로그래밍 두번째 약속, 두번째 필수요소, 변수의 불변성 보장]]

이렇게 해서 함수형 프로그래밍의 필수 구성요소 2가지를 살펴봤다.
함수의 순수성(pure function, 함수의 참조 불변성)과
변수의 불변성(immutability)
여러가지 측면에서 코드 퀄리티 향상에 도움이 되고
골치아플 다양한 오류를 미연에 방지하는 효과가 있기 때문에
함수형 프로그래밍을 하는지 아닌지와 상관없이
이 두 가지 원리이자 약속을 지키려고 의식적으로 노력하며
코드 작성하는 것을 추천한다.

<참조>
유튜브 영상, [Functional Programming in 40 Minutes • Russ Olsen • GOTO 2018](https://youtu.be/0if71HOyVjY?si=pbupT8bhNCO77KAL)

---------- ---------- ---------- ---------- ----------
[4] 불변 자료구조 구현방법 예시
URL ( 함수형-프로그래밍-시작해보기-4-불변-자료구조-구현-예시 )

여기서 소개하는 방법은 불변 자료구조를 구현할때
이런식으로 생각할 수 있다며 예시를 몇 가지 소개하고 있는 것이지
절대적인 정답은 아니다.
나중에 스스로 구현한 자료구조 또는 클래스에
Copy-On-Write 를 적용하고 싶다면 그때 그때 최적의 알고리즘을
선택하면 된다.

[[단방향 리스트 append]]

처음에 리스트 a 는 1,2,3,4 로 이루어져 있었다.
여기서 맨 뒤에 5 를 추가한 결과를 알고 싶다고 하자.
변수의 불변성이라는 원리를 적용하려면 아래와 같이 해야한다.
우선 원본 리스트 a 를 복사해서 1,2,3,4 를 가진 리스트 b 를 만든다.
리스트 a 는 건드리지 않고 리스트 b 에 새로운 요소 5 를 추가한다.
그리고 사용자에게 리스트 b 를 반환한다.
그러면 리스트 a 는 처음 그대로 1,2,3,4 가 들어있다
append 결과인 1,2,3,4,5 리스트도 올바르게 결과값으로 얻을 수 있다.

[[단방향 리스트 prepend]]

이번에는 맨 뒤 대신에 맨 앞에 0 을 추가한 결과를 알고 싶다고 하자.
처음에 리스트 a 를 복사해서 1,2,3,4 로 이루어진 리스트 b 를 얻는다.
여기서 리스트 a 는 건드리지 않고 리스트 b 에
새로운 요소 0 을 추가한다.
사용자에게는 리스트 b 를 반환한다.
그러면 리스트 a 는 처음 그대로 1,2,3,4 가 들어있고
prepend 결과인 0,1,2,3,4 리스트를 결과값으로 얻을 수 있다.

Copy-On-Write 에서 중요한 점은
리턴값이 처음부터 끝까지 복제된 대상이어야만 하는 법칙은 없다는 것이다.
그림 속 예시는 단방향 리스트이기 때문에
리스트에 대한 참조는 언제나 헤드, 즉 맨 앞 요소부터 시작한다.
그러므로 앞쪽에만 차이가 있고 뒤쪽의 요소들이 동일하다면
두 개의 리스트가 공통되는 요소 목록을 공유할 수 있다.
Copy-On-Write 방식이라고
언제나 메모리를 두배로 사용해야만 하는건 아니다.

[[단방향 리스트 update]]

update 는 갱신하려는 인덱스와 갱신 후 담아두려는 값
두 개의 파라미터를 입력받는 함수이다.
이를 구현하면 다음과 같이 된다.
처음에 리스트 a 를 복사해서 1,2,3,4 를 담고있는 리스트 b 를 얻는다.
여기서 리스트 a 는 건드리지 않고
리스트 b 의 1번 인덱스에 있는 요소를 5 로 변경한다.
그리고 나서 리스트 b 를 반환한다.
리스트를 갱신할때 차이가 나는 부분만,
즉 0번 인덱스부터 1번 인덱스까지는 복사해서
리스트 a 와 리스트 b 가 각자 적절한 요소를 참조하도록 구현하지만
공통되는 부분은 공유하므로써 컴퓨팅 리소스를 줄일 수 있다.
그러면 리스트 a 는 처음 그대로 1,2,3,4 가 들어있고
update 결과인 1,5,3,4 리스트도 올바르게 결과값으로 얻을 수 있다.

위의 방식도 나쁘지는 않지만
시간복잡도 라는 기준으로 분석해보면 다음과 같은 결론을 얻는다.
append 는 O(n)
append 는 O(1)
update 는 O(n)
런타임에 사용하는 메모리량이라는 기준으로 분석하더라도
최악의 경우에 거의 두 배가 된다.
pop 함수를 구현한다고 생각하면 맨 뒤에서 하나를 제거하기 때문에
원본 리스트 N 개를 그대로 복사해서
새로운 리스트 N-1 개를 만들어야하므로
조금 더 최적화할 방법이 없을까 고민하게 된다.

[[트리구조를 활용하기]]

트리구조를 사용하면 조금은 더 최적화할 수 있게 된다.
각각의 노드들은 일정한 개수로 묶어서 관리한다. 여기서는 3개씩 묶는다.
그래서 변경의 단위는 배열 전체가 아니라 3개씩 묶은 노드가 된다.

[[트리구조에서 변경하려는 요소 화살표로 가리키기]]

리스트 가운데 쯔음에 있는 n 이라는 요소를 Q 로 바꾼다고 해보자.

[[트리구조를 활용해서 변경 완료한 노드만 빨갛게 표시하기]]

그러면 이런식으로 빨간색으로 표시한 위치에 있는 노드들만
복제하고 나머지는 기존의 노드를 그대로 사용할 수 있게 된다.

여기서는 작은 스케일로 표현하기 위해서 3 이라는 단위를 선택했지만
실제로 구현할때는 16, 32 와 같이
어떤 케이스에든 일반적으로 적용했을때
이슈가 적게 발생할만한 숫자를 지정하는 게 바람직하다.

다시 한번 강조하지만 Copy-On-Write 원리를 구현하는데
어떤 절대적인 정답이 있는 것은 아니다.
여기서 설명하는 방식들은
나중에 필요한 경우에 브레인스토밍을 돕기 위해서 제공한
일종이 예시라고 생각하면 된다.

<참조>
유튜브 영상, [함수형 프로그래밍 3대장 경험기: 클로저, 스칼라, 하스켈 | 인프콘2023](https://youtu.be/H1izEfbg5QA?si=PmqNR5-XKhqbI5nX)
유튜브 영상, [Functional Programming in 40 Minutes • Russ Olsen • GOTO 2018](https://youtu.be/0if71HOyVjY?si=pbupT8bhNCO77KAL)

---------- ---------- ---------- ---------- ----------
[5] 신뢰할 수 없는 코드베이스에서 불변성 유지하기
URL ( 함수형-프로그래밍-시작해보기-5-방어적-복사 )

앞에서 함수형 프로그래밍을 소개하면서 '실용적' 이라는 단어를 사용했다.
프로그래머 입장에서 실용적이라는 말은
자신이 현업에서 다루고 있는 프로젝트에 즉시 적용할 수 있다는 의미이다.
하지만 소위 레거시코드 라고 부르는 프로젝트들은
함수형 프로그래밍의 원리에서 약속한
함수의 순수성, 변수의 불변성을 거의 존중하지 못하는 방식으로
구현되어 있을 것이다.

그런 코드베이스를 다루고 있는 프로그래머이더라도
위에서 언급한 함수형 프로그래밍의 원리를
빠르게 적용할 수 있는 방법이 있다.
'방어적 복사' 라는 방식을 채택하면 된다.

[[방어적 복사]]

방어적 복사는 간단하다.
위험한 함수, 즉 순수하지 않은 함수(impure funtion)을
호출하기 전에
전달하는 파라미터를 우선 복제한다.
그리고 이 복제본은 함수 호출 시 아규먼트로 사용한다.
그러면 함수를 호출하기 전에 먼저 선언했던 변수의 불변성을
명시적으로 보장할 수 있다.
함수의 실행이 완료되면 이 함수는 실행 결과를 리턴값이나 전역변수 등
어떤 방식으로든 되돌려준다.
이렇게 받은 결과를 사용해서 다음 로직을 진행하기 전에
먼저 한번 복제해서 사용하기로 한다.

순수 함수라는 것을 확실하게 알고 있는 함수를 호출할때는
이미 내부적으로 Copy-On-Write 원리를 적용하고 있을 것이기 때문에
방어적 복사를 하지 않고 곧바로 함수의 입출력값을 사용해도 될 것이다.
물론 일말의 불안감이라도 있다면
방어적 복사를 더 폭넓게 적용할 수도 있다.

<참조>

책, [쏙쏙 들어오는 함수형 코딩](https://jpub.tistory.com/1265) 7장, 에릭 노먼드, 김은민, 2022

---------- ---------- ---------- ---------- ----------
[6] 함수형 원리로 리팩터링하는 예제 1 - 액션, 계산, 데이터

"blog-posts.md" 파일에 저장

---------- ---------- ---------- ---------- ----------
[7] 함수형 원리로 리팩터링하는 예제 2 - 고차함수, 일급객체

"blog-posts.md" 파일에 저장

---------- ---------- ---------- ---------- ----------
[8] 함수형 프로그래밍 원리를 적용한 아키텍처
URL ( 함수형-프로그래밍-시작해보기-8-함수형-프로그래밍-게층형-구조 )

[[함수형 프로그래밍 계층 구조]]

함수형 프로그래밍 원리를 적용해서 구현하고 나면
전체 프로그램을 함수 호출 구조를 그래프로 나타내면
그림처럼 트리 형태가 된다.
아래쪽에 있는 함수일수록 언어 자체의 내장 라이브러리 기능에 가까워지고
위쪽에 있는 함수일수록 비즈니스 로직을 구현하는 내용에 가까워진다.

이런 게층형 구조는 여러 방식으로 해석할 수 있다.

[[코드를 수정하기 쉬운가?]]

이런 그래프에서
위쪽에 위치한 함수일수록 고치기 쉽고
아래쪽에 위치한 함수일수록 고치기 어렵다.
함수를 고친다는건 내부구현 로직을 변경한다는 것이다.
(조부모 함수) -> (부모 함수) -> (자식 함수)
순서로 함수들끼리 호출관계가 있다고 가정했을때
하나의 자식함수를 수정하고 나서도
전체 시스템이 오류없이 동작한다는 것을 보장하려면
그 자식 함수를 호출하는 모든 부모 함수를 확인해야 하고
여기서 확인한 부모 함수 각각을 호출하는 조부모 함수도 확인해야 한다.
그 이유는 아래쪽에 위치한 함수일수록
더 많은 부모함수들에서 그 자식함수를 호출하고 있을 것이기 때문이다.

[[얼마나 재사용성이 높은가?]]

앞에서도 언급했지만
아래쪽에 위치한 함수일수록 재사용성이 높아지고
위쪽에 위치한 함수일수록 적은 횟수 사용될 가능성이 높다.
그러므로 함수의 API 를 설계하고 내부 구현을 완료할때
아래쪽 계층에 있는 함수에 대해서 훨씬 더 많이 신경을 쓰는 것이 좋다.

[[테스트 코드를 작성했을까 얼마나 큰 가치를 지닐까?]]

이런 그래프에서
아래쪽에 위치한 함수일수록 테스트코드를 작성하기 쉽고
위쪽에 위치한 함수일수록 테스트코드를 작성하기 어렵다.
아래쪽에 있는 함수일수록 더 작은 단위로 잘개 쪼개져 있을 것이고
위쪽에 있는 함수일수록 비즈니스 도메인 로직을 포함해서
복잡한 상태일 것이다.
그러므로 위쪽에 있는 함수는 테스트코드를 작성할때
셋업 과정에서든 검증 과정에서든 고려해야할 사안 목록이 길어지고
아래쪽 함수는 반대가 된다.

추가적으로
아래쪽에 위치한 함수일수록 해당 함수에 대해서 작성한
테스트코드의 가치가 높아지고
위쪽에 위치한 함수일수록 해당 함수에 대해서 작성한
테스트코드의 가치가 낮아진다.
아래쪽의 함수일수록 더 많은 곳에서 부모함수에서 호출하고 있을 것이므로
해당 함수의 안정성을 보장했을때 더 넓은 범위까지
시스템의 안정성을 보장할 수 있게 된다.
위쪽의 함수들은 비즈니스 로직과 같이
언제든지 변할 수 있는 내용을 담고 있을 가능성이 높다.

[파아프라인 구조]

함수형 프로그래밍의 약속과 원리를
충분히 따르면서 작성한 프로그램의 전체 구조는
멀리서 보았을때 이런식으로 파이프라인 구조가 된다.

<참조>
책, [쏙쏙 들어오는 함수형 코딩](https://jpub.tistory.com/1265) 9장, 에릭 노먼드, 김은민, 2022
아티클, ['액션-계산-데이터' 관점으로 보는 함수형 프로그래밍 패러다임 | 요즘IT](https://yozm.wishket.com/magazine/detail/1485/), 테오의 프론트엔드, 2022

---------- ---------- ---------- ---------- ----------
[9] 함수의 순수성을 보장했을때의 장점
URL ( 함수형-프로그래밍-시작해보기-9-순수-함수-최적화-아이디어 )

'순수 함수(pure function)' 이라는 것에는 또다른 의미가 숨어있다.
순수 함수는
함수를 구현할때 필요한 모든 정보를 전부 항상 파라미터를 통해서 얻고
함수를 실행한 뒤에 얻은 결과를 언제나 리턴값으로 내보낸다.

[[순수 함수를 Lookup Table 로 그려서 설명하기]]

그렇기 때문에 모든 순수 함수는
언제나 Lookup Table 로 치환해서 생각할 수 있다.
어떤 함수가 순수 함수인지 아닌지를 판단하는 기준은
함수의 입력값, 출력값 쌍을 Lookup Table 로 표현할 수
있는지 없는지가 된다.

이런식으로 순수 함수는
프로그래머에게 아주 다양한 이점을 제공한다는 걸 알 수 있다.
훨씬 많은 장점이 있겠지만 여기서는 우선 크게 4가지를 소개해보겠다.

- (1) Memoization 최적화 가능
- (2) Lazy Evaluation 최적화 가능
- (3) Parallel Processing 적용하기에 편함
- (4) 테스트 작성이 훨씬 용이해짐

(1) Memoization 최적화

Memoization 은 값을 미리 게산해두는 것이다.
입력값에 따른 출력값이 정해져있기 때문에 컴퓨팅 리소스에 여유가 있을때
계산 결과값을 미리 저장해두면
나중에 실제로 함수를 호출해서 리턴값을 확인하려는 순간에
런타임 실행시간을 줄일 수 있다.

이런 논리를 극단적으로 추구하면
컴파일타임 프로그래밍(compile-time programming) 영역에 도달한다.
런타임에 하는 일을 전부 다 컴파일 타임에 계산해서 저장해두거나
아예 텍스트 자체를 치환하므로서
런타임에 실시간으로 발생하던 부하를 거의 0 으로 만드는 기법이다.

(2) Lazy Evaluation 최적화

Lazy Evaluation 은
함수를 호출하는 순간에 입력값에 대한 연산을 하는 대신에
함수의 연산 결과값을 사용하는 순간에 실제 연산을 실시하도록 만들어서
최대한 lazy 하게 만드는 기법이다.
입력값으로 아주 많은 양의 데이터를 넘겨서 함수를 호출하는 경우에
유용하다.
예를 들어서 f(L) 과 같이
리스트를 파라미터로 받는 함수가 있다고 가정해보자.
이 함수는 리스트의 각 요소에 대해서
어떤 처리 X 를 적용한 뒤에

이 처리를 결과를 같은 개수의 요소로 이루어진 리스트에 담아서 반환한다.
겉보기에는 문제가 없어보이지만
입력값으로 길이가 1000만 정도 되는 리스트를 받는다고 생각해보면
프로그램이 이 함수를 호출하는 부분에서 동작이 꽤나 오랫동안
blocking 상태로 있을꺼라는 걸 쉽게 짐작할 수 있다.
이와 같은 상황에서 lazy evaluation 원리를 적용하면
런타임 부하를 "어떤 처리 X" 를 완료하는데
걸리는 만큼으로 시간복잡도를 줄일 수 있다.
lazy evaluation 의 대표적인 예시가 generator 이다.

이런 원리를 적용해서
함수의 입출력 파라미터를 Stream 타입으로 지정해서 구현하면
제한된 컴퓨팅 리소스를 가지고 사실상 무한대를 다루는 것이 가능해진다.

(3) Parallel Processing 적용

순수 함수는 입력값, 출력값이 고정되어 있으므로
연산 순서에 따라서 실행결과가 달라지지 않는다.
순수 함수의 이러한 특성에 대해서 곰곰히 생각해보면
엄청나게 많은 입력값에 대해서
병렬처리가 가능하겠구나 하는 결론에 이를 수 있다.
길이가 1000만 인 리스트의 요소를 하나씩 처리하는 대신에
100만개씩 나눠서 처리할 수 있다면
한 개의 손이 일하는 것보다는 열 개의 손으로 일하는게
작업 속도가 훨씬 빠를거라는건 꽤나 명확하다.

물론 순차처리보다 병렬처리가 언제나 효율적인 것은 아니기 때문에
연산에 대한 메트릭을 실제로 측정해서 더 나은 옵션을 선택해야 한다.

(4) 테스트 작성이 용이해짐

Mock, Fake 객체를 사용하는 런던파 스타일이 선택하지 않고
실제 시스템을 사용해서 자동화된 테스트 코드를 실행하는
고전파 스타일을 선택한다면
테스트 코드를 실행하는 컨텍스트(시점, 환경설정 등)에 따라서
flaky test 가 되는 경우를 종종 발견할 것이다.
하지만 순수 함수에서는 그런일이 발생하지 않는다.
함수의 구현내용은 온전히 파라미터 입력값에 의존하기 때문이다.
개발자 입장에서 고려해야 할 사항이 하나 둘 줄어들기 때문에
테스트 코드를 작성하는 과정이 훨씬 덜 고통스러워진다.

이렇게 순수 함수의 장점을 네 가지 알아봤다.
여기서는 미처 생각하지 못했지만 다른 장점들이 또 있을 수 있다.

평소에 구현을 할때 함수의 순수성, 변수의 불변성이라는 특성을
항상 스스로에게 환기시키며 작업한다면 완성한 프로그램이
훨씬 안정적이고 유지보수하기 쉽다는 것을 느끼게 될 것이다.

<참조>
유뷰트 영상, [Functional Programming for Pragmatists • Richard Feldman • GOTO 2021](https://youtu.be/3n17wHe5wEw?si=tl7lphKYQk4iWylp)

---------- ---------- ---------- ---------- ----------
[10] 함수형 프로그래밍 배경 지식 1 - Normal World & Wrapper World
URL ( 함수형-프로그래밍-시작해보기-10-Normal-World-and-Wrapper-World )

함수형 프로그래밍은 수많은 순수 함수와 불변 변수를 사용해서
프로그램을 구현하기로 약속하는 것이라고 지금까지 살펴봤다.

그렇지만 다시 생각해보면 부수효과를 일으키지 않는 프로그램이
현실적으로 어떤 가치를 제공할 수 있는지 잘 모르겠다.
코드로 뭔가를 구현해서 실질적으로 의미있는 영향을 끼치는 작업을 하려면
반드시 부수효과를 동반할 수 밖에 없다.
HTTP 통신, TCP 통신 요청을 보내고 응답을 받아서 데이터를 처리하고
데이터베이스에 접근해서 데이터를 저장, 수정하고 이를 가공해야 한다.
로컬스토리지에 접근해서 정보를 일정한 형태로 적재하고 불러와야 한다.

이런식으로 생각하면
위에서 언급한 함수형 프로그래밍의 두 가지 필수 요소
함수의 참조 무결성(referential integrity) 그리고
변수의 불변성(immutability)과 함께
부수 효과를 효율적으로 다루는 것이 중요하다는 것을 알게 된다.

함수형 프로그래밍에서 부수효과를 다루는 방법을 이해하기에 앞서서
우선 함수형 프로그래머의 눈에 프로그래밍
세상이 어떻게 보이는지 살펴보자.

[[Normal World and Wrapper World]]

함수형 프로그래머의 눈에는 세상 모든 변수, 세상 모든 함수가
Normal World 와 Wrapper World 둘 중에
하나에 속한 것으로 보인다.
여기서 Wrapper World 는
Side-Effect World 를 의미하는 것으로
함수형 프로그래밍에서는 모든 변수와 함수를
부수효과가 있는 것과 부수효과가 없는 것으로 나눠서 생각한다고
추상적으로 생각할 수 있다.
아주 엄밀하게 파고 들면 이런 설명이 올바르다고 말할 수는 없지만
생각의 전개를 위해서는 이렇게 생각하면 편하다.
이 두 가지 각각이 무엇을 의미하는지 예시를 통해서 살펴보자.

[[what is an effect]]

effect 라는 말이 조금은 광범위하게 사용되는 느낌인데
effect 타입은 wrapper 타입의 일종이고
wrapper 타입은 자신이 감싸는 타입에 다른 의미를 추가한다.
이런식으로 제너릭 타입으로 표현되는 경우는 다
effect 타입, wrapper 타입이라고 생각하면 되고
제너릭 타입에 타입 파라미터로 전달되는 T 타입은
normal world 에 속한다고 생각하면 된다.

[[Normal World example]]

Normal World 에 속하는 요소들은
int, string, bool 처럼 wrapper 가 아닌 타입이라고
생각할 수 있다.
기본 타입(primitive type) 뿐만 아니라
User, Pet, Fruit, Employee, Department 와 같은
사용자 정의 타입도 normal 타입의 일종이다.
그리고 입력이 normal 타입이고 출력이 normal 타입인 함수도
Normal World 에 속한 항목 중 하나이다.
int -> string 함수는 normal 타입의 함수이고
User -> Employee 함수도 normal 타입의 함수이다.
이런식으로 wrapper 타입이 아니라면 다 normal 타입에 속한다.

[[Option World example]]

Option 이라는 타입은 언어마다 사용하는 단어는 다르지만
어떤값이 있거나 없거나 둘 중에 하나인 상태를 가리키는
wrapper 타입이다.
Option, Optional, Maybe, Either, Nullable 등등
자신의 언어에서 익숙한 타입을 떠올리면 된다.
Option World 는 Normal World 가 아니므로
Wrapper World 의 일종이다.
Option<int>, Option<string>, Option<bool> 은
Option World 에 속한 항목들이고
Option<T> -> Option<R> 타입의 함수도
Option World 에 속한다.

[[List World example]]

이런식으로 Wrapper World 는 엄청 많다.
여기서는 List World 의 예시를 보여주고 있다.

[[Async World example]]

Async World 는 다른 언어에서는
Promise, Future, CompletableFuter, Task 등의 용어로
표현하는 개념을 가리킨다.

[[Effect World example]]

세상에 존재하는 수많은 Wrapper World 를 추상화해서
Effect World 라고 일컬을 수 있다.
함수형 프로그래밍에서는 이런 effect 타입을 사용해서
부수효과를 적절하게 제어한다.

[[Normal World, Wrapper World 왕복 횡단 그림]]

처음에 부수효과를 다루기 위해서 코드를 구현해보면
이 그림과 같은 형태가 된다.
처음에 연산을 시작할때는 Normal World 에 속하는 어떤 값을 담고 있는
변수를 만들게 된다. normal 타입의 변수가 될 것이다.
부수효과를 다루기 위한 wrapper 타입으로 만들어서 1단계 처리를
실행한다.
1단계 처리가 완료되었으면 다음 처리를 위해서
wrapper 타입에서 값을 꺼내어 normal 타입 변수에 담는다.
이 변수를 2단계 처리를 위한 아규먼트로 전달한다.
함수형 프로그래밍에서 부수효과를 다룬다는 것은 위에서 설명한 것처럼
normal 타입 변수를 wrapper 타입으로 만들어서 태스크를 실행하고
wrapper 타입 응답값에서 다시 normal 타입을 꺼내고
이 꺼낸 값을 다시 wrapper 타입으로 만들어서 처리하는 과정을
반복하는 것이다.

하지만 함수형 프로그래머의 눈에
이렇게 두 가지 서로 다른 World 를 왕복 횡단하는 구조는
지나치게 고생스럽게 느껴진다.
이보다 더 편하고 깔끔하고 우아하게 처리할 방법이 없을까 고민하다가
다음과 같은 구조를 생각해냈다.

[[Normal World 에서는 시작과 끝에만 접근하고 중간 과정에서 Wrapper World 에만 있음]]

처리를 시작할때는 입력값을
Normal World 에서 Wrapper World 로 보내지만
중간과정에서는 계속해서 Wrapper World 에만 머무르도록 한다.
여러 단계로 지정한 파이프라인 연산을 모두 거치고 나면 최종결과값은
Wrapper World 에서 Normal World 로 되돌려보낸다.
그러면 Normal World 와 Wrapper World 사이를
횡단하는 과정은 사라져서
전체적인 구조는 훨씬 간소화되었지만
입력값과 결과값은 여전히 그대로이다.

이런 추상적인 아이디어를 코드레벨에서 구현하면 어떤 형태가 되는지
예시를 통해서 천천히 살펴보자.

<참조>
유뷰트 영상, [The Absolute Best Intro to Monads For Software Engineers](https://youtu.be/C2w45qRc3aU?si=I9BGOrdOR0_b3bEd)
유뷰트 영상, [Functional Design Patterns - Scott Wlaschin](https://youtu.be/srQt1NAHYC0?si=VRNjZpmAmAPgGNGv)

---------- ---------- ---------- ---------- ----------
[11] 함수형 프로그래밍 배경 지식 2 - 타입, 함수 합성, 부분 함수, 펑터(Functor)
URL ( 함수형-프로그래밍-시작해보기-11-타입-함수합성-부분함수-펑터 )

[[a type is a name for a set of things]]

타입(type)이란 무엇일까?
사실 타입에 대해서 얘기하려면 카테고리론부터 시작해서
추상 데이터 타입(Abstract Data Type) 등의 얘기를 해야하지만
여기서는 생각의 전개를 돕기 위해서 쉽게 접근하기로 한다.
타입은 어떤 것들에 집합(a set of things)에 이름을 붙이는 것이다.
집합이라고 하면 하나의 집합에 속한 요소끼리는
서로 공통된 속성을 공유하고 있으므로
동작하는 방식이나 해당 집합에 속한 요소에 접근하는 방식이 일원화된다.

함수형 프로그래밍에서 타입은 함수를 표현할때 사용한다.
함수의 입력값은 특정한 타입을 지니고 출력값도 특정한 타입을 지닌다.
그리고 함수조차도 입력값, 출력값 쌍으로 추론되는 타입을 갖는다.

[[여러가지 타입]]

이런건 정수 타입이고
이런건 문자열 타입이고
이런건 사람 타입이고

[[여러가지 타입 2]]

심지어는 이렇게 과일도 타입이 된다.
심지어는 함수도 타입으로 표현할 수 있다.
이렇게 하면 입력이 과일 타입이고 출력이 과일타입인 함수,
줄여서 Fruit-to-Fruit 타입의 함수가 된다.

[[함수 사상 그림 A -—f--> B]]

처음에 봤던 함수 그림으로 다시 돌아가서 시작해보자.
수학에서는 A 집합의 모든 요소 각각에서 B 집합의 어떤 하나의 요소로 대응시키는 관계를 f 라고 한다.
이를 프로그래밍에서는
함수 f 의 입력타입이 A 이고 출력타입이 B 라고 말한다.

[[함수 합성]]

그림처럼 여러 개의 함수가 있을때
함수 f 의 입력타입은 A 이고 출력타입은 B 이다.
함수 g 의 입력타입은 B 이고 출력타입은 C 이다.
이렇게 f 와 g 의 관게처럼
한 함수의 출력타입과 다른 함수의 입력타입이 같은 타입이라면
함수 f 와 g 를 합성해서 새로운 함수처럼 사용할 수 있다.
그러면 이렇게 합쳐서 얻어낸 새로운 함수 g o f 는
입력타입이 A 이고 출력타입이 C 인 함수가 된다.
이를 함수 합성(function composition)이라고 한다.

[[부분 함수]]

지금까지 설명을 할때 항상
함수는 입력타입과 출력타입이 있고
해당 타입에 맞는 입력값을 전달해서 호출하면
계산 결과로 명시한 출력타입에 맞는 값을 반환한다고 서술했다.

하지만 프로그래밍 세계에서 실제로는 꼭 그렇지만은 않다.
명세 타입에 맞는 값을 아규먼트로 입력한다고 하더라도
어떤 이유에서든 함수가 예외를 던질 수가 있다.
어떤 함수가 예외를 던진다면
더 이상 입력값에 대해서 올바른 출력값이 내보내는 함수가 아니다.
치밀한 이론과 완벽한 논리로 무장하는 수학의 세계에서와 달리
프로그래밍의 세계에서 함수는 거짓말을 친다.
이런식으로 올바른 타입의 값을 입력하더라도
출력타입에 맞는 리턴값을 되돌려주지 않는 함수를
부분 함수(partial function)라고 한다.

[[Functor - f, g, map, map(g)]]

함수형 프로그래밍 관련해서 중요한 개념 중 하나로 Functor 가 있다.
함수형 프로그래밍에서 부수효과를 다루는데 핵심이 되는 개념이므로
한번 살펴보고 넘어가자.

이해를 돕기 위해서 그림을 그려보겠다.
여기 그림들에서 '모양 + 색깔' 조합이 하나의 타입을 의미한다.
모양과 색깔이 모두 같은 컴포넌트는 서로 같은 타입이고
모양과 색깔중에 하나라도 다르면 서로 다른 타입이다.
먼저 가장 왼쪽 위에 있는 파란색 원 컴포넌트는 어떤 타입이다.
파란색원 컴포넌트를 입력으로 해서 펑터(Functor) F 를 호출하면
박스 안에 담긴 파란색 원 컴포넌트가 된다.
박스 안에 담긴 파란색 원 컴포넌트는
위에서 언급한 wrapper 타입이라고 생각하면 된다.
파란색 원을 입력으로 해서 함수 g 를 호출하면 노란색 원을 출력한다.
노란색 원 컴포넌트와 박스 안에 담긴 노란색 원 컴포넌트는 서로
펑터(Functor) 관계에 있다.
여기서 맵(Map) 이라는 개념이 등장한다.
맵(Map) 은 함수를 들어올리는(life the function) 고차함수이다.
오른쪽에 있는 함수 각각의 시그니처를 보면 보다 이해가 쉬운데
함수 map 은
A -> B 라는 시그니처의 함수 g 를 파라미터로 받아서
F[A] -> F[B] 라는 타입의 함수를 반환한다고
함수 시그니처가 표현되어 있다.
그래서 함수 map(g) 는 F[A] -> F[B] 라는 시그니처를 갖는다.

객체지향 프로그래밍 언어에 익숙한 사람이라면
해당 언어에도 map 이라는 함수가 있지만
함수 시그니처가 이와 달라서 낯선 느낌을 받을 것이다.
이는 객체지향 언어에서는 어떤 클래스 안에 메서드로 구현했기 때문에
아이디어만 차용하고 구현방식에 맞춰서 타입을 변경하다보니
그렇게 된 듯하다.
본질적인 개념을 추적하다보면 map 함수에 대해서
여기서 설명하는 방식이 본래의 의미에 더 가깝다는 것을 알게 될 것이다.
전통적인 함수형 프로그래밍 언어에서는 클래스 개념이 없기 때문에
map 함수를 static function 으로 구현하게 되고
자연스럽게 함수 시그니처도 (A -> B) -> (F[A] -> F[B]) 가 된다.

[[map 함수 시그니처 추가 설명을 위한 Optional, List 예시]]

다음과 같은 함수 g 가 있다.
함수 g 는 입력타입이 파란색 원이고 출력타입이 노란색 원이다.
이럴때 파란색 원에 대한 Optional 이 있을 수 있다.
Optional 은 실제 내부구현은 다를 수도 있지만
개념적으로는 파란색 원에 대한 Some 이거나 Empty
둘 중에 하나의 값을 갖는 객체라고 보면 된다.
여기서 파란색 원에 대한 Some 을 입력으로 해서 map(g) 를 호출하면
노란색 원에 대한 Some 이 된다.
앞쪽에서 함수 map 의 시그니처는
(A -> B) -> (F[A] -> F[B]) 라고 했고
어떤 함수를 입력으로 해서 함수 map 을 호출한 함수 map(g)
F[A] -> F[B] 시그니처를 갖는 함수를 출력한다고 설명했다.
그러므로 Some<파란색 원> 을 입력으로 map(g) 를 호출하면
출력값으로 Some<노란색 원> 을 얻게 된다.
Empty<파란색 원> 을 입력으로 map(g) 를 호출하면
출력값으로 Empty<노란색 원> 을 얻는다.
이렇게 하면
Some 과 Empty 의 조합으로 이루어진 Optional 에 대해서도
map 함수를 적용할 수 있게 된다.

List 타입에 속한 항목에 대해서 똑같이 map 함수를 적용할 수 있다.
List<파란색 원> 을 입력으로 해서 map(g) 를 호출하면
출력으로 List<노란색 원> 을 얻게 된다.

이 부분을 계속 보다보면 map 함수는
내용물을 감싸고 있는 박스의 모양을 항상 보존한다는 것을 알 수 있다.
map 함수는 어떤 데이터의 내용물(content)만 바꾸고
그 데이터의 구조(structure)는 바꾸지 않는다.

여기까지가 Functor 가 무엇인지 아주 간단하게만 소개한 내용이다.
Functor 개념을 정확하게 이해하려면 대수적인 개념도 이해해야 하고
다른 개념도 함께 알아봐야 하지만
우선은 최대한 프로그래머로서 이해하는데 문제없는 수준에서
풀어내려고 노력해봤다.
Functor 는 map 메서드를 가진 제너릭 인터페이스라고 말할 수 있곘다.

여기까지 쌓은 관련 배경 지식을 바탕으로
함수형 프로그래밍에서 부수효과(side effect)를
어떻게 다루는지 알아보자.

<참조>
유뷰트 영상, [Functional Design Patterns - Scott Wlaschin](https://youtu.be/srQt1NAHYC0?si=VRNjZpmAmAPgGNGv)
유튜브 영상, [No Nonsense Monad & Functor - The foundation of Functional Programming by César Tron-Lozai](https://youtu.be/e6tWJD5q8uw?si=i6wagObBBBht_wsD)

---------- ---------- ---------- ---------- ----------
[12] 함수형 프로그래밍에서 부수효과(side effect)를 다루는 방법 1
URL ( 함수형-프로그래밍-시작해보기-12-부수효과를-다루는-방법-1 )

구체적인 예시를 통해서
함수형 프로그래밍에서 부수효과(side effect) 다루는 방법을
확인해보자.

[[split, parse, divide 내부구현]]

요구조건을 간단하게 설명하면 이렇다.
처음에 입력값으로 문자열을 입력받는다.
숫자 두 개를 고르고 가운데 쉼표(,)를 넣은 뒤에 하나의 문자열로 합치면
올바른 입력값이 된다.
이렇게 입력받은 문자열을 쉼표를 기준으로 두 개의 문자열로 나눈 뒤에
두 개의 문자열을 각각 숫자로 변환한 후에
이렇게 얻은 두 개의 숫자를 나눈 결과값을 반환한다.
최종적으로 출력타입은 실수 타입이 된다.

위의 요구조건을 만족하기 위해서는
세 단게의 태스크를 거쳐야 하므로
자연스럽게 세 개의 함수로 구현하게 된다.
split 함수에서 쉼표를 기준으로 문자열을 분리하고
parse 함수에서 두 개의 문자열을 숫자로 변환하고
divide 함수로 나누기 결과값을 얻어낸다.

[[split, parse, divide 함수 합성]]

앞에 세 개의 함수 split, parse, divide 는 서로 서로
입력타입과 출력타입이 서로 맞아서 split -> parse -> divide 로
세 개의 함수를 한줄로 합성하는게 가능해진다.

앞쪽에 세 개의 함수
split, parse, divide 의 내부구현을 다시 보자.
이 세 개의 함수는 겉보기는 순수 함수 같지만
자세히 드려다보면 split, parse, divide 모두
부분 함수(partial function)이다.
split 함수의 입력 파라미터가 null 이라면
String.split() 메서드를 호출하는 부분에서 예외가 발생한다.
parse 함수의 입력 파라미터 문자열 쌍에서
둘 중에 하나라도 숫자가 아닌 문자가 섞여 있다면 예외가 발생한다.
divide 함수의 입력 파라미터 실수 쌍에서
분모가 되는 두번째 실수값이 0 이라면 예외가 발생한다.

예외처리 방법은 여러가지가 있지만
여기서는 Optional<T> 타입을 사용하기로 하자.
Optional<T> 는 T 타입의 값이 있거나 empty 상태이거나
둘 중의 하나의 값을 가지는 객체이다.
이 Optional 을 사용해서 위의 세 가지 함수의 타입을
에외처리를 자연스럽게 완료한 상태로 만들어보자.

[[split, parse, divide 세 개의 함수에 예외처리 로직 추가]]

이제 위 세 개의 함수는 이런식으로 바뀐다.
split 함수는 입력타입이 String 이고
출력타입은 String 쌍의 Optional 이다.
parse 함수는 입력타입이 String 쌍의 Optional 이고
출력타입은 Double 쌍의 Optional 이다.
divide 함수는 입력타입이 Double 쌍의 Optional 이고
출력타입은 Double 의 Optional 이다.

[[split, parse, divide 세 개의 함수 호출 후 ifPresent() 확인 처리]]

Optional 을 사용하면 구현결과는 이런식이 된다.
split, parse, divide 라는 세 개의 태스크를 실행하되
앞선 태스크가 성공했을때만 다음 태스크를 실행한다.
split 실행이 성공하면,
즉 if (split.isPresent() == true) 이면
다음 함수인 parse 를 실행한다.
parse 실행이 성공하면,
즉 if (parse.isPresent() == true) 이면
다음 함수인 divide 를 실행한다.
divide 실행이 성공하면,
즉 if (divide.isPresent() == true) 이면
최종 결과값을 반환한다.
이런식으로 구현하면 예외처리를 빈틈없이 완벽하게 구현했기 때문에
지금 상태에서도 만족해도 충분하다.
하지만 이것은 프로그래머들이 흔히들 콜백헬(callback hell)이라고
부르는 것과 비슷한 결과를 불러왔다.
지금은 함수호출이 세 개 밖에 없으니 인덴트가 그다지 깊지 않지만
하나의 요구조건을 만족하기 위해서 필요한 태스크가 많아질수록
이 콜백헬이 그려내는 죽음의 트라이앵글도 점점 커질 것이다.

[[더 이상 split, parse, divide 함수 합성은 불가능]]

이 그래프를 보면 무엇이 달라졌는지 한 눈에 잘 보인다.
앞에서 split, parse, divide 함수의 타입이 딱딱 맞아떨어질 때는
세 개의 함수를 합성해서 하나의 함수인 것처럼
깔끔하게 한 줄로 만들 수 있었다.
그러나 지금은 그런 깔끔한 one-liner 가 불가능하다.
왜냐하면 split, parse, divide 의 입력타입과 출력타입이
서로 일치하지 않기 때문이다.

앞에서 코드에서 본 콜백헬 모양의 삼각형을 없애고
타입이 바뀐 split, parse, divide 세 가지를 합수 합성을 통해서
마치 하나의 함수를 호출한 것처럼 만드는 것이
함수형 프로그래밍이 추구하는 방향성이다.

[[kleisli arrow, fish operator]]

앞의 함수를 보다 추상화시켜서 분석해보자.
함수 f 는 A -> M[B] 타입이고
함수 g 는 B -> M[C] 타입이다.
함수형 프로그래밍에서는 출력값이 M[B] 이고 입력값이 B 인
두 개의 함수 f, g 를 합성해주는 것은 kleisli arrow 라고 하고
>=> 와 같이 표시한다.
>=> 를 보면 물고기처럼 생겼기 때문에 fish oprator 라고도 부른다.

오른쪽에 타입명세를 살펴보자.
함수 f 와 g 를 합성하려면
M[B] 를 B 로 만들어줄 무언가가 필요하다.

[[Functor 다시 살펴보기]]

아니면 아예 다른 방향에서 접근해서
합성해서 얻어낸 함수 g o f 자체의 타입에만 집중해보자.
함수 g o f 의 타입은 A -> M[C] 이다.
그러면 중간단계는 어떻든지 상관없이
입력타입이 A 이고 마지막 출력타입이 M[C] 가 되게만 하면 되지 않을까?

[[Functor 사용해서 flatten-map(g)-f 형태로 함수 합성]]

박스 안에 어떤 타입이 담겨있다고 할때
박스에서 안쪽에 저장된 내용물을 꺼내는 것을 flatten 이라고 해보자.
그랬을때 위의 그림과 같이
f - map(g) - flatten 순서로 합성하고 나면
최종함수 (flatten o map(g) o f) 는 A -> M[C] 타입을 갖는다.
이런식으로 하면
앞에 있는 함수의 출력값이 박스 안에 있는 X 타입이고
뒤에 있는 함수의 입력값이 그냥 X 타입이어도
다시 한 줄로 깔끔하게 함수 합성을 할 수 있게 되었다.

[[Monad - f, g, map(g) - flatten, flatMap]]

프로그래밍에서는 map(g) 과 flatten 합성하는 과정이 자주 등장하는데
흔히 flatMap 이라고 줄여서 부른다.

오른쪽에 각 함수의 타입명세를 살펴보면
A 는 normal 타입이고 M 은 wrapper 타입이다.
M[A] 는 박스 안에 담겨진 색깔있는 원이라고 생각하면 된다.
함수 f 는 A -> M[B] 타입이고
함수 g 는 B -> M[C] 타입이다.
map 함수는 (A -> B) -> (M[A] -> M[B]) 타입이다.
flatMap 함수는 (A -> M[B]) -> (M[A] -> M[B]) 타입이다.
함수 g >=> f 는 내부적으로
x -> flatMap(g)(f(x)) 를 호출하는 것과 같아지고
결과적으로는 처음에 살펴본 것처럼 A -> M[C] 타입이 된다.

[[flatMap 사용해서 개선한 split, parse, divide 함수 합성]]

지금까지 알아본 flatMap 을 적용해서
세 개의 함수 split, parse, divide 를 다시 합성해보면
위의 그림과 같은 형태가 된다.

이제 우리는 함수형 프로그래밍의 독특한 무기 두 가지
map 함수와 flatMap 함수 사용하는 법을 알게 되었다.
함수 이름이나 타입 명세는
구현하는 언어마다 맥락마다 프레임워크마다 다를 수 있지만
기본적인 원리는 이런 형태가 될 것이다.
이 두 가지를 기억하면서 필요한 때마다 적절하게 선택해서 사용하면
자연스럽게 함수형 프로그래밍 원리를 적용해서
모든 부수효과를 더 잘 다룰 수 있게 된다.

방금 설명한 내용이 간단하게 말하면 Monad 를 코드에 적용한 결과이다.
물론 Monad 에는 지금 이상의 미묘한 내용들이 들어있지만
함수형 프로그래밍 관점에서 Monad 를 코드레벨에 적용한다면
이런식으로 된다.
Monad 는 flatMap 원리를 구현한 메서드를 가진
Functor 라고 말할 수 있곘다.

<참조>
유튜브 영상, [No Nonsense Monad & Functor - The foundation of Functional Programming by César Tron-Lozai](https://youtu.be/e6tWJD5q8uw?si=i6wagObBBBht_wsD)

---------- ---------- ---------- ---------- ----------
[13] 함수형 프로그래밍에서 부수효과(side effect)를 다루는 방법 2 - 또다른 비유
URL ( 함수형-프로그래밍-시작해보기-12-부수효과를-다루는-방법-2-또다른-비유 )

[[Task 예시코드 - taskX, taskY, taskZ 순서대로 실행]]

이번엔 Optional 말고 다른 wrapper 타입을 예시로 들어서 살펴보자.
어떤 작업을 비동기적으로 실행한 후에 결과값이 돌아왔을때
그 출력값으로 다음 작업을 진행하는 것도 부수효과(side effect)이다.
왜냐하면 함수 스코프를 벗어난 위치에 영향을 주기 때문이다.
이런 부수효과를 보다 편하게 다루기 위해서
Promise, Task, Future, Completable 등등
다양한 wrapper 타입이 존재한다.
위의 그림에서는 세 개의 태스크 X, Y, Z 를 순서대로 실행한다.
태스크 X 실행이 성공하면 다음 태스크 Y 를 실행하고
태스크 Y 실행이 섵공하면 다음 태스크 Z 를 실행하는 방식이다.
중간에 하나라도 실패한다면 그 결과값은 null 이 된다.
이를 위해서는 실패하는 경우에 대해서 예외처리를 해야하므로
그림과 같이 계속에서 인덴트가 안으로 들어가서
죽음의 삼각형이 만들어진다.
앞에서 설명한 원리를 여기에도 적용하면
코드를 한결 정제된 상태로 개선할 수 있다.

[[철길 들어가는 길은 하나, 나오는 길은 둘]]

그림과 같은 철길을 생각해보자.
기차가 달리고 있을때 갈림길에서
선로가 어느 방향으로 조정되어 있느냐에 따라서
기차가 위쪽 철길을 탈지 아래쪽 철길을 탈지가 달라진다.
함수도 이와 마찬가지이다.
어떤 함수를 실행하면 성공할 수도 있고 실패할 수도 있다.
성공하는 케이스를 초록색 철길을 타는 경우,
예외를 던지거나 오류가 발생하는 경우를 빨간색 철길이라고 생각하자.

[[철길 두 개를 나란히 두면]]

앞에서 세 개의 태스크 X, Y, Z 를 차례로 실행할때
앞에 태스크가 성공해야만 다음 태스크를 실행한다고 했다.
여기 철길 그림에서도 마찬가지이다.
앞쪽 갈림길에서 초록색 길로 가야만 다음 갈림길에 도달할 수 있다.

[[철길 세 개 합치기]]

궁극적으로는 이런식으로 태스크 X, Y, Z 를 합쳐두는게 목적이다.

[[composing switches is not allowed]]

여기에는 문제가 있다.
여러개의 철로를 문제없이 이으려면
앞에 철로 갈림길과 뒤에 철로가 갈림길의 입구 개수와 출구 개수가
같아야 한다.
그래서 위의 그림과 같은 형태의 철로는 서로 연결할 수가 없다.

[[bind 예시]]

이런 문제를 해결해주는 것은 바로 Bind 이다.
그림 속 bind 함수 내용에서
Success 케이스는 위쪽의 초록색 철로를 타는 것이고
Failure 케이스는 아래쪽의 빨간색 철로를 타는 것과 같다.

[[taskExample 원래 코드와 새로 추가하는 taskBind 함께 보여주기]]

앞에서 세 개의 태스크 X, Y, Z 실행하는 코드를 다시 살펴보면
whenFinished 처리하는 부분을
bind 함수로 옮겨서 처리할 수 있을 것 같다.
조금 전에 살펴본 bind 라는 아이디어를 적용해서
taskBind 라는 함수를 구현해보자.

[[taskBind 적용해서 리팩터링]]

새롭게 추가한 taskBind 라는 적용해서
기존의 코드를 리팩터링하면 이렇게 된다.
바로 이전 포스팅에서 자주 본 것처럼
함수 합성을 통해서 한 줄로 깔끔하게 정리한 것과 같은 효과가 나타난다.

[[updateCustomer 예시코드]]

조금 더 현실적인 가상의 요구조건을 생각해서 예시코드를 생각해보자.
클라이언트에서 HTTP 요청을 받은 후
HTTP 요청의 형태가 유효한 형식인지 확인하고
이메일 문자열을 전처리하고
사용자 요청한 내용을 데이터베이스에 저장한 후에
사용자에게 성공적으로 처리 완료했다고 이메일로 알리는
서비스를 만들었다.
지금 코드는 아주 좋다.
직관적으로 비즈니스 로직을 파악할 수 있다.

[[updateCustomer 예외처리 추가한 예시코드]]

하지만 실제로 릴리즈를 하려면
예외처리를 통해서 코드를 안정화해야 한다.
validation 로직에서 오류가 발생할 수 있다.
데이터베이스 update 쿼리 실행중에 오류가 발생할 수 있고
sendEmail 과정에서 오류가 발생할 수 있다.
그러므로 이런식으로 예외처리 코드를 추가하는 것은 너무나 당연해보인다.

하지만 이런식으로 예외처리를 하나 둘 추가하다보면
나중에는 중간중간 디테일이 너무 많이 끼어들어서
유지보수하는 개발자들이 로직의 전체적인 플로우를 파악하기 어렵게 만든다.

[[validateInput 함수에 bind 원리 적용한 예시]]

이런 어려움을 극복하기 위해서
앞에서 살펴본 bind 원리를 적용할 수 있다.
validateInput 이라는 함수는
성공하거나 실패할 수 있는 철로 갈림길이다.
그러므로 예외처리 로직을 함수 내부로 끌고 온 후
실행이 성공하는 경우 Success 결과값을 반환하고
실행중에 오류가 발생하면 Failure 케이스에 맞는
처리를 하도록 변경한다.

[[validate, updateDb, sendEmail 모두 철로 갈림길로 비유하기]]

에외가 발생할 가능성이 있는 모든 함수를 이런식으로 철로 갈림길 다루듯이
bind 로직을 적용하고 나면

[[깔끔하게 one-liner 로 만든 결과]]

이런식으로 다시 비즈니스 로직을 파악하기 쉬운 형태가 되었다.

함수형 프로그래밍에서는
bind, >=>(kleisli arrow), flatMap 셋은 모두 동일한 개념을 가리킨다.
이런식으로 함수형 프로그래밍의 원리를 적절하게 적용하면
각자가 다루는 코드베이스를 개선할 수 있다.
처음에 모를때는 너무 어려워보이지만
일단 한번 패턴을 익히고 나면
함수형 프로그래밍의 원리를 코드에 적용하는 것은 그다지 어렵지 않다.

<참조>
유뷰트 영상, [Functional Design Patterns - Scott Wlaschin](https://youtu.be/srQt1NAHYC0?si=VRNjZpmAmAPgGNGv)

---------- ---------- ---------- ---------- ----------
[14] 부수효과 다루는 방법을 적용해서 리팩터링하는 예제

---------- ---------- ---------- ---------- ----------
[15] 함수형 프로그래밍 잘 시작해보기(요약 정리)
URL ( 함수형-프로그래밍-시작해보기-15-요약-정리 )

함수형 프로그래밍을 처음 시작하려는 사람에게
도움이 될만한 짧다면 짧고 길다면 길 시리즈를 한번 준비해봤다.
이 시리즈 작성을 시작할때
나도 함수형 프로그래밍에 대해서 제대로 접근해본 적 없었다.
그렇기 때문에
나 스스로가 함수형 프로그래밍 내공이 아주 좋다고 말하기는 힘들 것이다.
주변에서 또는 원래 알지 못했더라도 온라인에서
함수형 패러다임에 익숙한 분들을 찾아서 질문을 하면서
이 시리즈를 완성해나갔다.

[[함수형 프로그래밍 필수요소 두 가지]]

함수형 프로그래밍 원리의 핵심은 두 가지만 기억하면 된다.

- 함수의 순수성 보장하기
- 변수의 불변성 보장하기

이 글을 읽는 분들이
색다른 관점을 통해서 새로운 통찰력을 얻어가는
유익한 시간이 되었으면 좋겠다.

이번 시리즈를 만들면서 참고한 영상, 도서, 아티클 링크를 여기에 첨부한다.

<참조>
책, [쏙쏙 들어오는 함수형 코딩](https://jpub.tistory.com/1265) 7장, 에릭 노먼드, 김은민 역, 2022
책, [함수형 사고](https://www.hanbit.co.kr/store/books/look.php?p_code=B6064588422), 닐 포드, 김재환 역, 2016
책, [코틀린 함수형 프로그래밍](http://www.acornpub.co.kr/book/function-pro-kotlin), (마르코 버뮬런, 루나르 비야르나손 & 폴 치우사), (오현석 & 서형국) 역, 2023
아티클, ['액션-계산-데이터' 관점으로 보는 함수형 프로그래밍 패러다임 | 요즘IT](https://yozm.wishket.com/magazine/detail/1485/), 테오의 프론트엔드, 2022
유튜브 영상, [The Absolute Best Intro to Monads For Software Engineers](https://youtu.be/C2w45qRc3aU?si=yb-1J9BEcR2kO-Pl)
유튜브 영상, [No Nonsense Monad & Functor - The foundation of Functional Programming by César Tron-Lozai](https://youtu.be/e6tWJD5q8uw?si=G094NnYbdVaNwgkJ)
유튜브 영상, [[Dev Dive_ Backend Day] 하스켈로 백엔드 시스템 만든 이야기](https://youtu.be/YBLZGUeNSu4?si=AbiyyIcSTa0MiF_r)
유튜브 영상, [Functional Programming in 40 Minutes • Russ Olsen • GOTO 2018](https://youtu.be/0if71HOyVjY?si=SCgve1q9gWqnlOY0)
유튜브 영상, [What is a Monad? - The Last Monad Intro You'll Ever Need](https://youtu.be/HIBTu-y-Jwk?si=iLEX1xFyhbofmFi7)
유튜브 영상, [Functional Programming for Pragmatists • Richard Feldman • GOTO 2021](https://youtu.be/3n17wHe5wEw?si=XAHaHhxJUfWbEvp_)
유튜브 영상, [The Functional Programmer's Toolkit - Scott Wlaschin](https://youtu.be/Nrp_LZ-XGsY?si=8OKLScwtnkn-_2xX)
유튜브 영상, [Monads are everywhere... Maybe that's bad? by Till Schröder](https://youtu.be/nGhoZzihbHY?si=2CTp8KAOiCYTjMbb)
유튜브 영상, [The purest coding style, where bugs are near impossible](https://youtu.be/HlgG395PQWw?si=oMxKzIvlmYy9jbr4)
유튜브 영상, [Why Functional Programming Matters • John Hughes • YOW! 2017](https://youtu.be/JQDRCTa32jY?si=w56i36cLQ6XPfy7L)
유튜브 영상, [Functional Design Patterns - Scott Wlaschin](https://youtu.be/srQt1NAHYC0?si=mHEcE4g-qc6pVMPo)
유튜브 영상, [함수형 프로그래밍 3대장 경험기: 클로저, 스칼라, 하스켈 | 인프콘2023](https://youtu.be/H1izEfbg5QA?si=DJVdRn9MUbQJ0_RO)
유튜브 영상, [From Dependency injection to dependency rejection - Mark Seemann](https://youtu.be/cxs7oLGrxQ4?si=SaaQhUpY1PGofsZX)

---------- ---------- ---------- ---------- ----------


